////////////////////////////////////////////////////////////////
// 의도 추측 : var를 사용하지 않는 이유를 명확히 알고 있는지 알아보고자
// 개념 : var에는 여러 문제점이 존재하는데 초기화를 하지 않은 변수도 사용이 가능하다는 점과 같은 이름 중복 선언,
// 함수레벨 스코프를 사용하고 있어서 변수를 의도치 않게 변경되는 경우가 발생합니다. 
// let과 const는 이런점을 보완하고 있고 차이는 let은 재할당이 가능하고 const 재할당이 되지않는다는 점입니다.

////////////////////////////////////////////////////////////////

function useVar() {
  // 변수를 선언하기전에 사용하면 undefined가 초기화 되어있습니다.
  console.log(선언전변수);
  var 선언전변수 = "변수를 사용후 선언했습니다.";
  
  // 변수명을 같은 이름으로 선언 할 수 있습니다.
  var 중복된선언 = "중복해서 선언이 될까요?";
  var 중복된선언 = "네 중복해서 됩니다.";
  var 중복된선언 = "네 두번도 됩니다.";
  var 중복된선언 = "네 세번도 됩니다.";
  console.log(중복된선언);

  // 같은 이름의 변수를 다른 범위에서 사용해도 전역번수가 변합니다. 다른 함수에서 선언한 경우만 다른 변수로 할당 됩니다.(함수레벨 스코프)
  var 함수전역변수 = "함수 전역변수입니다.";
  if(true) {
    var 함수전역변수 = "함수전역변수를 다른 범위에서 또 다시 선언했습니다.";
  }
  console.log(함수전역변수);

}

function useLet() {
  // 선언하기전 변수를 사용하면 참조에러를 발생시킵니다. 초기화가 되기전까지 참조못하는 구간을 TDZ(Temporal Dead Zone)라고 합니다.
  // console.log(선언전변수);
  // let 선언전변수let = "변수를 사용후 선언했습니다.";

  // 같은 이름으로 중복된 선언이 안됩니다(같은 범위에서). 에러도 발생시키지만 애초에 편집기에서부터 경고가 나오네요.
  // let 중복된선언let = "중복해서 선언이 될까요?";
  // let 중복된선언let = "no.";
  // let 중복된선언let = "nono.";
  // let 중복된선언let = "nonono.";
  // console.log(중복된선언);

  // let은 재할당이 가능합니다.
  let 재할당변수 = "before";
  재할당변수 = "after";
  console.log(재할당변수);

  // let, const는 블록레벨 스코프가 적용되어 전역변수와 내부 다른 범위의 변수명이 같아도 다른 변수로 할당됩니다.
  let 함수전역변수 = "함수 전역변수입니다.";
  if(true) {
    let 함수전역변수 = "함수전역변수를 다른 범위에서 또 다시 선언했습니다.";
  }
  console.log(함수전역변수);
}

function useConst() {
  // 선언하기전 변수를 사용하면 참조에러를 발생시킵니다. 
  // console.log(선언전변수);
  // const 선언전변수 = "변수를 사용후 선언했습니다.";

  // const는 선언과 초기화가 같이 이루어져야합니다.
  const 선언과초기화 = 1;

  // const 선언만;
  // 선언만 = 1;

  // const는 재할당이 안되지만 객체의 값은 변경 가능합니다.
  const 바뀌지않는상수 = "바뀌나요?";
  // 바뀌지않는상수 = "no";
  const 객체 = { a : "바뀌나요?"};
  객체.a = "네";
  console.log(객체);

}

useVar();
useLet();
useConst();